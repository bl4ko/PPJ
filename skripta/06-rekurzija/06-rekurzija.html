
<!DOCTYPE html>

<html lang="sl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>6. Rekurzija in rekurzivni tipi &#8212; Principi programskih jezikov</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css%3Fdigest=c3fdc42140077d1ad13ad2f1588a4309.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Abecedni seznam" href="../genindex.html" />
    <link rel="search" title="Išči" href="../search.html" />
    <link rel="next" title="7. Izpeljava tipov" href="../07-izpeljava-tipov/07-izpeljava-tipov.html" />
    <link rel="prev" title="5. Deklarativno programiranje" href="../05-deklarativno-programiranje/05-deklarativno-programiranje.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="sl">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Principi programskih jezikov</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Poiščite to knjigo ..." aria-label="Poiščite to knjigo ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../00-uvod.html">
   Uvod
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../01-aritmeticni-izrazi/01-aritmeticni-izrazi.html">
   1. O programskih jezikih in aritmetičnih izrazih
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../02-ukazni-programski-jezik/02-ukazni-programski-jezik.html">
   2. Ukazni programski jezik
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../03-dokazovanje-pravilnosti/03-dokazovanje-pravilnosti.html">
   3. Dokazovanje pravilnosti programov
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04-lambda-racun/04-lambda-racun.html">
   4. λ-račun
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../05-deklarativno-programiranje/05-deklarativno-programiranje.html">
   5. Deklarativno programiranje
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="06-rekurzija.html#">
   6. Rekurzija in rekurzivni tipi
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../07-izpeljava-tipov/07-izpeljava-tipov.html">
   7. Izpeljava tipov
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../08-abstrakcija/08-abstrakcija.html">
   8. Specifikacija, implementacija, abstrakcija
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../09-logicno-programiranje/09-logicno-programiranje.html">
   9. Logično programiranje
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../10-programiranje-z-omejitvami/10-programiranje-z-omejitvami.html">
   10. Logično programiranje z omejitvami
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../11-podtipi/11-podtipi.html">
   11. Podtipi
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../12-objektno-programiranje/12-objektno-programiranje.html">
   12. Objektno programiranje
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../14-haskell-in-razredi-tipov/14-haskell-in-razredi-tipov.html">
   13. Haskell in razredi tipov
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../15-monade/15-monade.html">
   14. Monade in računski učinki
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../13-ucinki-in-prestrezniki/13-ucinki-in-prestrezniki.html">
   15. Učinki in prestrezniki
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Preklopi navigacijo" aria-controls="site-navigation"
                title="Preklopi navigacijo" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Prenesite to stran"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/06-rekurzija/06-rekurzija.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Prenesite izvorno datoteko" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Natisni v PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Celozaslonski način"
        title="Celozaslonski način"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Vsebina
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#splosna-oblika-rekurzije">
   6.1. Splošna oblika rekurzije
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#rekurzivna-funkcija-vec-argumentov">
     6.1.1. Rekurzivna funkcija več argumentov
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#hkratna-rekurzivna-definicija">
     6.1.2. Hkratna rekurzivna definicija
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#iteracija-je-poseben-primer-rekurzije">
     6.1.3. Iteracija je poseben primer rekurzije
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#rekurzivne-podatkovne-strukture">
     6.1.4. Rekurzivne podatkovne strukture
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#rekurzivni-in-induktivni-tipi">
   6.2. Rekurzivni in induktivni tipi
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#induktivni-tipi">
     6.2.1. Induktivni tipi
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#primer-naravna-stevila">
   6.3. Primer: naravna števila
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#splosni-rekurzivni-tipi">
     6.3.1. Splošni rekurzivni tipi
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#strukturna-rekurzija">
     6.3.2. Strukturna rekurzija
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#koinduktivni-tipi">
   6.4. Koinduktivni tipi
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#tokovi">
     6.4.1. Tokovi
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#tokovi-v-haskellu">
     6.4.2. Tokovi v Haskellu
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#tokovi-v-ocamlu">
     6.4.3. Tokovi v OCamlu
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#vhod-izhod-kot-koinduktivni-tip">
     6.4.4. Vhod/izhod kot koinduktivni tip
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Rekurzija in rekurzivni tipi</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Vsebina </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#splosna-oblika-rekurzije">
   6.1. Splošna oblika rekurzije
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#rekurzivna-funkcija-vec-argumentov">
     6.1.1. Rekurzivna funkcija več argumentov
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#hkratna-rekurzivna-definicija">
     6.1.2. Hkratna rekurzivna definicija
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#iteracija-je-poseben-primer-rekurzije">
     6.1.3. Iteracija je poseben primer rekurzije
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#rekurzivne-podatkovne-strukture">
     6.1.4. Rekurzivne podatkovne strukture
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#rekurzivni-in-induktivni-tipi">
   6.2. Rekurzivni in induktivni tipi
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#induktivni-tipi">
     6.2.1. Induktivni tipi
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#primer-naravna-stevila">
   6.3. Primer: naravna števila
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#splosni-rekurzivni-tipi">
     6.3.1. Splošni rekurzivni tipi
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#strukturna-rekurzija">
     6.3.2. Strukturna rekurzija
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="06-rekurzija.html#koinduktivni-tipi">
   6.4. Koinduktivni tipi
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#tokovi">
     6.4.1. Tokovi
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#tokovi-v-haskellu">
     6.4.2. Tokovi v Haskellu
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#tokovi-v-ocamlu">
     6.4.3. Tokovi v OCamlu
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="06-rekurzija.html#vhod-izhod-kot-koinduktivni-tip">
     6.4.4. Vhod/izhod kot koinduktivni tip
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="rekurzija-in-rekurzivni-tipi">
<h1><span class="section-number">6. </span>Rekurzija in rekurzivni tipi<a class="headerlink" href="06-rekurzija.html#rekurzija-in-rekurzivni-tipi" title="Povezava na naslov">¶</a></h1>
<p>Rekurzija je eden od osnovnih konceptov v računalništvu, ki se pojavlja na različnih nivojih.</p>
<div class="section" id="splosna-oblika-rekurzije">
<h2><span class="section-number">6.1. </span>Splošna oblika rekurzije<a class="headerlink" href="06-rekurzija.html#splosna-oblika-rekurzije" title="Povezava na naslov">¶</a></h2>
<p>Obravnavajmo rekurzivno funkcijo <code class="docutils literal notranslate"><span class="pre">f</span></code>, ki računa faktorielo. V Javi bi jo zapisali takole:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ekvivalentna definicija v Pythonu:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Ekvivalentna definicija v OCamlu:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>Definicijo razstavimo na dva dela: na <em>telo</em> rekurzije, ki samo po sebi ni rekurzivno, in na
<em>rekurzivni sklic</em> funkcije <code class="docutils literal notranslate"><span class="pre">f</span></code> same nase:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">telo</span> <span class="n">g</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">g</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">n</span> <span class="o">=</span> <span class="n">telo</span> <span class="n">f</span> <span class="n">n</span>
</pre></div>
</div>
<p>Samo drugi del je rekurziven. Še malo drugače:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">telo</span> <span class="n">g</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">g</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">n</span> <span class="o">=</span> <span class="n">telo</span> <span class="n">f</span> <span class="n">n</span>
</pre></div>
</div>
<p><em>Vsako</em> rekurzivno funkcijo lahko razstavimo na ta način in drugi del je vedno enak.
Definirajmo si funkcijo <code class="docutils literal notranslate"><span class="pre">rek</span></code> (v angleščini običajno <code class="docutils literal notranslate"><span class="pre">rec</span></code> ali <code class="docutils literal notranslate"><span class="pre">fix</span></code>), ki sprejme telo
rekurzivne definicije <code class="docutils literal notranslate"><span class="pre">t</span></code> in vrne pripadajočo rekurzivno funkcijo:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">rek</span> <span class="n">t</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">(</span><span class="n">rek</span> <span class="n">t</span><span class="o">)</span> <span class="n">x</span>
</pre></div>
</div>
<p>Vsa rekurzija je shranjena v <code class="docutils literal notranslate"><span class="pre">rek</span></code>, od tu naprej je ne potrebujemo več:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">rek</span> <span class="o">(</span><span class="k">fun</span> <span class="n">self</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">self</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)))</span>
</pre></div>
</div>
<p>Poglejmo tip funkcije <code class="docutils literal notranslate"><span class="pre">rek</span></code>. OCaml je izpeljal njen tip:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">((</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span>
</pre></div>
</div>
<p>Tipa <code class="docutils literal notranslate"><span class="pre">'a</span></code> in <code class="docutils literal notranslate"><span class="pre">'b</span></code> sta <em>parametra</em>, ki označujeta poljubna tipa. Zapišimo lepše z <code class="docutils literal notranslate"><span class="pre">α</span></code> in <code class="docutils literal notranslate"><span class="pre">β</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>((α → β) → (α → β)) → (α → β)
</pre></div>
</div>
<p>Preberemo: »<code class="docutils literal notranslate"><span class="pre">rek</span></code> je funkcija, ki sprejme funkcijo <code class="docutils literal notranslate"><span class="pre">t</span></code> tipa <code class="docutils literal notranslate"><span class="pre">(α</span> <span class="pre">→</span> <span class="pre">β)</span> <span class="pre">→</span> <span class="pre">(α</span> <span class="pre">→</span> <span class="pre">β)</span></code> in vrne funkcijo
tipa <code class="docutils literal notranslate"><span class="pre">α</span> <span class="pre">→</span> <span class="pre">β</span></code>.«</p>
<p>Poglejmo postopek še enkrat, tokrat zapisan z λ-računom:</p>
<ol class="simple">
<li><p>Prvotna definicija <code class="docutils literal notranslate"><span class="pre">f</span></code> se glasi:     <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">if</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">1</span> <span class="pre">else</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">f</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1)</span></code></p></li>
<li><p>Zapišemo s pomočjo λ-abstrakcije:  <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">λ</span> <span class="pre">n</span> <span class="pre">.</span> <span class="pre">if</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">1</span> <span class="pre">else</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">f</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1)</span></code></p></li>
<li><p>Ločimo rekurzijo in telo funkcije: <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">t</span> <span class="pre">f</span></code> kjer je <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">(λ</span> <span class="pre">g</span> <span class="pre">n</span> <span class="pre">.</span> <span class="pre">if</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">1</span> <span class="pre">else</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">g</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1))</span></code></p></li>
<li><p>S pomočjo <code class="docutils literal notranslate"><span class="pre">rek</span></code> definiramo <code class="docutils literal notranslate"><span class="pre">f</span></code>:        <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">rek</span> <span class="pre">t</span></code></p></li>
</ol>
<p>Kadar imamo preslikavo <span class="math notranslate nohighlight">\(h\)</span> in točko <span class="math notranslate nohighlight">\(x\)</span>, ki zadošča enačbi <span class="math notranslate nohighlight">\(x = h(x)\)</span>, pravimo, da je <span class="math notranslate nohighlight">\(x\)</span> <strong>negibna
točka</strong> preslikave <span class="math notranslate nohighlight">\(h\)</span>. V numeričnih metodah je eden od osnovnih postopkov reševanja enačb ta,
da enačbo zapišemo v obliki <span class="math notranslate nohighlight">\(x = h (x)\)</span> in nato iščemo njeno rešitev kot zaporedje približkov</p>
<div class="math notranslate nohighlight">
\[
x_0,  h(x_0),  h(h(x_0)),  h(h(h(x_0))), \ldots
\]</div>
<p>Negibne točke so pomembne tudi na drugih področjih matematike in o njih matematiki veliko vedo.</p>
<p><em>Opomba:</em> če imam enačbo <span class="math notranslate nohighlight">\(\ell(x) = d(x)\)</span>, jo lahko prepišemo v obliko <span class="math notranslate nohighlight">\(x = d(x) - \ell(x) + x\)</span> in definiramo
<span class="math notranslate nohighlight">\(h(x) = d(x) - \ell(x) + x\)</span>, da dobimo <span class="math notranslate nohighlight">\(x = h(x)\)</span>.</p>
<p>Ugotovili smo, da je tudi rekurzivna definicija funkcije <span class="math notranslate nohighlight">\(f\)</span> pravzaprav enačba, ki ima
oblike negibne točke:</p>
<div class="math notranslate nohighlight">
\[
f = t f
\]</div>
<p>Pomnimo:</p>
<blockquote>
<div><p><strong>Rekurzivno definirana funkcija je negibna točka.</strong></p>
</div></blockquote>
<div class="section" id="rekurzivna-funkcija-vec-argumentov">
<h3><span class="section-number">6.1.1. </span>Rekurzivna funkcija več argumentov<a class="headerlink" href="06-rekurzija.html#rekurzivna-funkcija-vec-argumentov" title="Povezava na naslov">¶</a></h3>
<p>Ali to deluje tudi za rekurzivne funkcije dveh argumentov? Seveda!</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">(n,</span> <span class="pre">k)</span> <span class="pre">=</span> <span class="pre">(if</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">n</span> <span class="pre">else</span> <span class="pre">s</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">k,</span> <span class="pre">k</span> <span class="pre">-</span> <span class="pre">1))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">λ</span> <span class="pre">(n,</span> <span class="pre">k)</span> <span class="pre">.</span> <span class="pre">if</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">n</span> <span class="pre">else</span> <span class="pre">s</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">k,</span> <span class="pre">k</span> <span class="pre">-</span> <span class="pre">1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">t</span> <span class="pre">s</span></code>, kjer je <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">λ</span> <span class="pre">self</span> <span class="pre">.</span> <span class="pre">λ</span> <span class="pre">(n,</span> <span class="pre">k)</span> <span class="pre">.</span> <span class="pre">if</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">n</span> <span class="pre">else</span> <span class="pre">self</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">k,</span> <span class="pre">k</span> <span class="pre">-</span> <span class="pre">1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">rek</span> <span class="pre">t</span></code></p></li>
</ol>
</div>
<div class="section" id="hkratna-rekurzivna-definicija">
<h3><span class="section-number">6.1.2. </span>Hkratna rekurzivna definicija<a class="headerlink" href="06-rekurzija.html#hkratna-rekurzivna-definicija" title="Povezava na naslov">¶</a></h3>
<p>Kaj pa definicija rekurzivnih funkcij <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">g</span></code>, ki kličeta druga drugo?
Primer: funkcija <code class="docutils literal notranslate"><span class="pre">f</span></code> kliče <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">g</span></code>, funkcija <code class="docutils literal notranslate"><span class="pre">g</span></code> pa kliče <code class="docutils literal notranslate"><span class="pre">f</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">g</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="ow">and</span> <span class="n">g</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>Če obravnavamo <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">g</span></code> skupaj kot urejeni par <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">g)</span></code> dobimo</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(f, g) = ((λ x . if x = 0 then 1 + f (x - 1) else 2 + g (x - 1)),
          (λ y . if y = 0 then 1 else 3 * f (y - 1)))
</pre></div>
</div>
<p>To je <em>rekurzivna definicija urejenega para (funkcij)</em>, kar prepišemo v</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(f, g) = t (f, g)
</pre></div>
</div>
<p>kjer je</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>t = λ (f&#39;, g&#39;) . ((λ x . if x = 0 then 1 + f&#39; (x - 1) else 2 + g&#39; (x - 1)),
                 (λ y . if y = 0 then 1 else 3 * f&#39; (y - 1)))
</pre></div>
</div>
<p>Torej tudi za hkratne rekurzivne definicije velja, da so to <strong>negibne točke</strong>.</p>
</div>
<div class="section" id="iteracija-je-poseben-primer-rekurzije">
<h3><span class="section-number">6.1.3. </span>Iteracija je poseben primer rekurzije<a class="headerlink" href="06-rekurzija.html#iteracija-je-poseben-primer-rekurzije" title="Povezava na naslov">¶</a></h3>
<p>V proceduralnem programiranju poznamo zanke, na primer zanko <code class="docutils literal notranslate"><span class="pre">while</span></code>. Ali je tudi ta negibna
točka? Če upoštevamo ekvivalenco</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while b do c done
</pre></div>
</div>
<p>in</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if b then (c ; while b do c done) else skip
</pre></div>
</div>
<p>vidimo, da je zanka <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">b</span> <span class="pre">do</span> <span class="pre">c</span> <span class="pre">done</span></code> negibna točka. Če pišemo <code class="docutils literal notranslate"><span class="pre">W</span></code> za našo zanko:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>W ≡ (if b then (c ; W) else skip)
</pre></div>
</div>
<p>Torej je <code class="docutils literal notranslate"><span class="pre">W</span></code> in s tem zanka <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">b</span> <span class="pre">do</span> <span class="pre">c</span> <span class="pre">done</span></code> negibna točka funkcije:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>t = (λ W . if b then (c ; W) else skip)
</pre></div>
</div>
<p>saj velja</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(while b do c done) = t (while b do c done)
</pre></div>
</div>
<p>Tudi <strong>iteracija</strong> je negibna točka!</p>
<p><em>Opomba:</em> zanko <code class="docutils literal notranslate"><span class="pre">while</span></code> lahko na zgornji način »odvijamo v nedogled«:</p>
<p>Faza 0:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while b do c done
</pre></div>
</div>
<p>Faza 1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if b
then
  (c ; while b do c done)
else skip
</pre></div>
</div>
<p>Faza 2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if b
then
  (c ;
   if b
   then
     (c ; while b do c done)
   else skip
  )
else skip
</pre></div>
</div>
<p>Faza 3:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if b
then
  (c ;
   if b
   then
     (c ;
      if b
      then
        (c ; while b do c done)
      else skip
     )
   else skip
  )
else skip
</pre></div>
</div>
<p>In tako naprej. Če bi lahko imeli neskončno programsko kodo, ne bi potrebovali zank!</p>
</div>
<div class="section" id="rekurzivne-podatkovne-strukture">
<h3><span class="section-number">6.1.4. </span>Rekurzivne podatkovne strukture<a class="headerlink" href="06-rekurzija.html#rekurzivne-podatkovne-strukture" title="Povezava na naslov">¶</a></h3>
<p>Rekurzivno lahko definiramo tudi ostale strukture, ne samo funkcije. Na primer,
neskončni seznam</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ℓ = [1; 2; 1; 2; 1; 2; ...]
</pre></div>
</div>
<p>lahko definiramo kot</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ℓ = 1 :: 2 :: ℓ
</pre></div>
</div>
<p>OCaml dopušča take definicije v omejeni meri (in tudi niso uporabne, ker je OCaml neučakan jezik).
Haskell omogoča splošne rekurzivne definicije podatkov.</p>
</div>
</div>
<div class="section" id="rekurzivni-in-induktivni-tipi">
<h2><span class="section-number">6.2. </span>Rekurzivni in induktivni tipi<a class="headerlink" href="06-rekurzija.html#rekurzivni-in-induktivni-tipi" title="Povezava na naslov">¶</a></h2>
<p>Do sedaj smo spoznali podatkovne tipe:</p>
<ul class="simple">
<li><p>produkt <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> in zapisi</p></li>
<li><p>vsota <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code></p></li>
<li><p>eksponent <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">→</span> <span class="pre">b</span></code></p></li>
</ul>
<p>S temi konstrukcijami ne moremo dobro predstaviti bolj naprednih podatkovnih tipov, kot so
seznami in drevesa. Poglejmo na primer, kako se tvori sezname celih števil:</p>
<ul class="simple">
<li><p>prazen seznam: <code class="docutils literal notranslate"><span class="pre">[]</span></code> je seznam</p></li>
<li><p>sestavljen seznam: če je <code class="docutils literal notranslate"><span class="pre">x</span></code> celo število in <code class="docutils literal notranslate"><span class="pre">ℓ</span></code> seznam, je tudi <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">::</span> <span class="pre">ℓ</span></code> seznam</p></li>
</ul>
<p>Zapis <code class="docutils literal notranslate"><span class="pre">[1;</span> <span class="pre">2;</span> <span class="pre">3]</span></code> je okrajšava za <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">::</span> <span class="pre">(2</span> <span class="pre">::</span> <span class="pre">(3</span> <span class="pre">::</span> <span class="pre">[]))</span></code>.</p>
<p>Seznami so <strong>rekurzivni podatkovni tip</strong>, saj gradimo sezname iz seznamov. Brez uporabe
posebnih oznak <code class="docutils literal notranslate"><span class="pre">[]</span></code> in <code class="docutils literal notranslate"><span class="pre">::</span></code> bi zgornjo definicijo zapisali takole (oznaki <code class="docutils literal notranslate"><span class="pre">Nil</span></code> in <code class="docutils literal notranslate"><span class="pre">Cons</span></code> izhajata
iz programskega jezika LISP, kjer pišemo <code class="docutils literal notranslate"><span class="pre">nil</span></code> in <code class="docutils literal notranslate"><span class="pre">(cons</span> <span class="pre">x</span> <span class="pre">ℓ)</span></code>):</p>
<ul class="simple">
<li><p>prazen seznam: <code class="docutils literal notranslate"><span class="pre">Nil</span></code> je seznam</p></li>
<li><p>sestavljen seznam: če je <code class="docutils literal notranslate"><span class="pre">x</span></code> celo število in <code class="docutils literal notranslate"><span class="pre">ℓ</span></code> seznam, je tudi <code class="docutils literal notranslate"><span class="pre">Cons</span> <span class="pre">(x,</span> <span class="pre">ℓ)</span></code> seznam</p></li>
</ul>
<p>Seznam <code class="docutils literal notranslate"><span class="pre">[1;</span> <span class="pre">2;</span> <span class="pre">3]</span></code> je okrajšava za <code class="docutils literal notranslate"><span class="pre">Cons</span> <span class="pre">(1,</span> <span class="pre">Cons</span> <span class="pre">(2,</span> <span class="pre">Cons</span> <span class="pre">(3,</span> <span class="pre">Nil)))</span></code>.</p>
<p>V OCamlu se tako definicijo zapiše takole:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">seznam</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Nil</span>
  <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">seznam</span>
</pre></div>
</div>
<p>Spet imamo opravka z rekurzijo. Tipi, ki se sklicujejo sami nase v svoji definiciji, se
imenujejo <strong>rekurzivni tipi</strong>.</p>
<p>In spet vidimo, da je rekurzija negibna točka. Podatkovni tipi <code class="docutils literal notranslate"><span class="pre">seznam</span></code> je negibna točka za
preslikavo <code class="docutils literal notranslate"><span class="pre">T</span></code>, ki slika tipe v tipe:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seznam = T (seznam)
</pre></div>
</div>
<p>kjer je <code class="docutils literal notranslate"><span class="pre">T</span></code> definiran kot</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T a = (Nil | Cons of int * a)
</pre></div>
</div>
<p>Z besedami: <code class="docutils literal notranslate"><span class="pre">T</span></code> je funkcija, ki sprejme poljuben tip <code class="docutils literal notranslate"><span class="pre">a</span></code> in vrne vsoto tipov
<code class="docutils literal notranslate"><span class="pre">Nil</span> <span class="pre">|</span> <span class="pre">Cons</span> <span class="pre">of</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
<div class="section" id="induktivni-tipi">
<h3><span class="section-number">6.2.1. </span>Induktivni tipi<a class="headerlink" href="06-rekurzija.html#induktivni-tipi" title="Povezava na naslov">¶</a></h3>
<p>Izhajamo iz definicije seznama:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">seznam</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">seznam</span>
</pre></div>
</div>
<p>Vprašajmo se: ali ta definicija zajema neskončne sezname? Na primer:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="nc">Cons</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="o">...)))))</span>
</pre></div>
</div>
<p>Ali se mora to kdaj zaključiti z <code class="docutils literal notranslate"><span class="pre">Nil</span></code>? Možna sta dva odgovora. Če zahtevamo, da morajo
biti elementi rekurzivnega tipa končni, govorimo o <em>induktivnih</em> tipih. Če pa dovolimo
neskončne elemente, govorimo o <em>koinduktivnih</em> tipih.</p>
<p>Poglejmo najprej <strong>induktivne podatkovne tipe</strong>. To so rekurzivni tipi, v katerih
vrednosti sestavljamo začenši z osnovnimi s pomočjo konstruktorjev in neskončne vrednosti
niso dovoljene. Primeri:</p>
<ol class="simple">
<li><p>naravna števila</p></li>
<li><p>končni seznami</p></li>
<li><p>končna drevesa</p></li>
<li><p>abstraktna sintaksa jezika:</p>
<ul class="simple">
<li><p>programski jeziki</p></li>
<li><p>jeziki za označevanje podatkov</p></li>
</ul>
</li>
<li><p>hierarhija elementov v uporabniškem vmesniku</p></li>
</ol>
</div>
</div>
<div class="section" id="primer-naravna-stevila">
<h2><span class="section-number">6.3. </span>Primer: naravna števila<a class="headerlink" href="06-rekurzija.html#primer-naravna-stevila" title="Povezava na naslov">¶</a></h2>
<p>Definicija naravnega števila:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> je naravno število</p></li>
<li><p>če je <code class="docutils literal notranslate"><span class="pre">n</span></code> naravno število, je tudi <code class="docutils literal notranslate"><span class="pre">n⁺</span></code> naravno število (ki mu rečemo »naslednik <code class="docutils literal notranslate"><span class="pre">n</span></code>«)</p></li>
</ul>
<p>Definicija podatkovnega tipa:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">stevilo</span> <span class="o">=</span> <span class="nc">Nic</span> <span class="o">|</span> <span class="nc">Naslednik</span> <span class="k">of</span> <span class="n">stevilo</span>
</pre></div>
</div>
<p>Ta definicija ni učinkovita, ker predstavi naravna števila z naslednikom, torej v »eniškem« sistemu.
Naravna števila bi lahko definirali tudi takole:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> je naravno število</p></li>
<li><p>če je <code class="docutils literal notranslate"><span class="pre">n</span></code> naravno število, je tudi <code class="docutils literal notranslate"><span class="pre">shl0</span> <span class="pre">n</span></code> naravno število</p></li>
<li><p>če je <code class="docutils literal notranslate"><span class="pre">n</span></code> naravno število, je tudi <code class="docutils literal notranslate"><span class="pre">shl1</span> <span class="pre">n</span></code> naravno število</p></li>
</ul>
<p>Ideja: z <code class="docutils literal notranslate"><span class="pre">shl0</span> <span class="pre">n</span></code> predstavimo število <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">·</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">0</span></code> in z <code class="docutils literal notranslate"><span class="pre">shl1</span> <span class="pre">n</span></code> predstavimo število <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">·</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>.
Primer: število</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shl0 (shl1 (shl0 (shl1 0)))
</pre></div>
</div>
<p>je število <code class="docutils literal notranslate"><span class="pre">10</span></code>. Kot podatkovni tip:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>type stevilo = Zero | Shl0 of stevilo | Shl1 of stevilo
</pre></div>
</div>
<p>Vendar to še vedno ni optimalna rešitev, ker lahko število nič predstavimo na neskončno načinov:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 = Shl0 0 = Shl0 (Shl0 0) = Shl0 (Shl0 (Shl0 0)) = ⋯
</pre></div>
</div>
<div class="admonition-vaja admonition">
<p class="admonition-title">Vaja</p>
<p>Poiščite predstavitev dvojiških števil z induktivnimi tipi (lahko jih je več), da bo
imelo vsako nenegativno celo število natanko enega predstavnika.</p>
</div>
<div class="admonition-primer admonition">
<p class="admonition-title">Primer</p>
<p><a class="reference external" href="http://json.org">Definicijo standarda JSON</a> in iz nje izluščimo podatkovni tip:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">json</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">String</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="nc">Number</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="nc">Object</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="nc">Array</span> <span class="k">of</span> <span class="n">json</span> <span class="kt">array</span> <span class="c">(* Ocaml ima vgrajen array *)</span>
  <span class="o">|</span> <span class="nc">True</span>
  <span class="o">|</span> <span class="nc">False</span>
  <span class="o">|</span> <span class="nc">Null</span>
</pre></div>
</div>
</div>
<div class="section" id="splosni-rekurzivni-tipi">
<h3><span class="section-number">6.3.1. </span>Splošni rekurzivni tipi<a class="headerlink" href="06-rekurzija.html#splosni-rekurzivni-tipi" title="Povezava na naslov">¶</a></h3>
<p>Rekurzivni tipi so lahko zelo nenavadni:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">d</span> <span class="o">=</span> <span class="nc">Foo</span> <span class="k">of</span> <span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="o">)</span>
</pre></div>
</div>
<p>Poskusite si predstavljati, kaj so vrednosti tega tipa…</p>
</div>
<div class="section" id="strukturna-rekurzija">
<h3><span class="section-number">6.3.2. </span>Strukturna rekurzija<a class="headerlink" href="06-rekurzija.html#strukturna-rekurzija" title="Povezava na naslov">¶</a></h3>
<p>Ker so induktivni podatkovni tipi definirani rekurzivno, jih običajno obdelujemo z
rekurzivnimi funkcijami. Kot primer si oglejmo, kako bi implementirali iskalna drevesa.</p>
<p>Obravnavajmo preprosta <strong>iskalna drevesa</strong>, v katerih hranimo cela števila. Iskalno drevo je</p>
<ul class="simple">
<li><p>bodisi <strong>prazno</strong></p></li>
<li><p>bodisi <strong>sestavljeno</strong> iz korena, ki je označen s številom <code class="docutils literal notranslate"><span class="pre">x</span></code>, ter dveh poddreves <code class="docutils literal notranslate"><span class="pre">l</span></code> in
<code class="docutils literal notranslate"><span class="pre">r</span></code> pri čemer velja:</p>
<ul>
<li><p>vsa števila v vozliščih <code class="docutils literal notranslate"><span class="pre">l</span></code> so manjša od <code class="docutils literal notranslate"><span class="pre">x</span></code>,</p></li>
<li><p>vsa števila v vozliščih <code class="docutils literal notranslate"><span class="pre">r</span></code> so večja od <code class="docutils literal notranslate"><span class="pre">x</span></code></p></li>
</ul>
</li>
</ul>
<p>Primer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>       5
      / \
     3   8
      \   \
       4  10
         /  \
        9   20
</pre></div>
</div>
<p>Podatkovni tip v OCaml se glasi:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">searchtree</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">searchtree</span> <span class="o">*</span> <span class="n">searchtree</span>
</pre></div>
</div>
<p>V tipu <em>nismo</em> shranili informacije o tem, da je iskalno drevo urejeno! Če bo programer
ustvaril iskalno drevo, ki ni pravilno urejeno, prevajalnik tega ne bo zaznal.</p>
<div class="admonition-naloga admonition">
<p class="admonition-title">Naloga</p>
<p>Sestavite funkcije za iskanje, vstavljanje in brisanje elementov v iskalnem drevesu.</p>
</div>
</div>
</div>
<div class="section" id="koinduktivni-tipi">
<h2><span class="section-number">6.4. </span>Koinduktivni tipi<a class="headerlink" href="06-rekurzija.html#koinduktivni-tipi" title="Povezava na naslov">¶</a></h2>
<p>Poznamo še en pomembno vrsto rekurzivnih tipov, to so <strong>koinduktivni tipi</strong>. Pojavljajo se v
računskih postopkih, ki so po svoji naravi lahko neskončni.</p>
<p>Tipičen primer koinduktivnega tipa je <strong>komunikacijski tok podatkov:</strong></p>
<ul class="simple">
<li><p>bodisi je tok podatkov prazen (komunikacije je konec)</p></li>
<li><p>bodisi je na voljo sporočilo <code class="docutils literal notranslate"><span class="pre">x</span></code> in preostanek toka</p></li>
</ul>
<p>Primere take komunikacije najdemo povsod, kjer program komunicira z okoljem ali
z drugim programom: odjemalec s strežnikom, dva programa med seboj, program z
uporabnikom ipd.</p>
<p>Če preberemo zgornjo definicijo kot induktivni tip, se ne razlikuje od
definicije seznamov. To bi pomenilo, da bi moral biti komunikacijski tok vedno
končen, kar je nespametna predpostavka. V praksi seveda komunikacija ni
<em>dejansko</em> neskončna, a je <em>potencialno</em> neskončna, kar pomeni, da lahko dva
procesa komunicirata v nedogled in brez vnaprej postavljene omejitve.</p>
<p><strong>Koinduktivni tipi</strong> so rekurzivni tipi, ki dovoljujejo tudi neskončne vrednosti.
Vendar pozor, kadar imamo opravka z neskončno velikimi seznami, drevesi itd.,
moramo paziti, kako z njimi računamo. Izogniti se moramo temu, da bi neskončno
veliko drevo ali komunikacijski tok poskušali izračunati v celoti do konca.</p>
<p>Haskell ima koinduktivne podatkovne tipe.</p>
<div class="section" id="tokovi">
<h3><span class="section-number">6.4.1. </span>Tokovi<a class="headerlink" href="06-rekurzija.html#tokovi" title="Povezava na naslov">¶</a></h3>
<p>Poglejmo različico tokov, ki so vedno neskončni, ker pri njih koinduktivna narava pride
še bolj do izraza. Tok je:</p>
<ul class="simple">
<li><p>sestavljen iz sporočila in preostanka toka</p></li>
</ul>
<p>Če to definicijo preberemo induktivno, dobimo <em>prazen</em> tip, saj ne moremo
začeti. Res, če zapišemo v OCaml</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">stream</span>
</pre></div>
</div>
<p>dobimo podatkovni tip, ki nima nobene končne vrednosti. Vrednost bi bila nujno neskončna, na primer:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cons</span> <span class="pre">(1,</span> <span class="pre">Cons</span> <span class="pre">(2,</span> <span class="pre">Cons</span> <span class="pre">(3,</span> <span class="pre">Cons</span> <span class="pre">(4,</span> <span class="pre">…))))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Cons</span> <span class="pre">(1,</span> <span class="pre">Cons</span> <span class="pre">(1,</span> <span class="pre">Cons</span> <span class="pre">(1,</span> <span class="pre">Cons</span> <span class="pre">(1,</span> <span class="pre">…))))</span></code></p></li>
</ul>
<p>OCaml sicer dopušča <em>nekatere</em> take vrednosti z definicijo <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">rec</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span> <span class="o">;;</span>
<span class="k">val</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">&lt;</span><span class="n">cycle</span><span class="o">&gt;))</span>
</pre></div>
</div>
<p>A te vrednosti le pokvarijo induktivno naravo tipov, hkrati pa ne dovoljujejo
poljubnih neskončnih vrednosti. Če bi imele v praksi uporabno vrednost, bi jih
morda tolerirali, ker pa jih redkokdaj uporabimo, smo lahko nekoliko razočarani
nad odločitvijo snovalcev OCamla, da jih dovolijo.</p>
</div>
<div class="section" id="tokovi-v-haskellu">
<h3><span class="section-number">6.4.2. </span>Tokovi v Haskellu<a class="headerlink" href="06-rekurzija.html#tokovi-v-haskellu" title="Povezava na naslov">¶</a></h3>
<p>Ista definicija v Haskellu deluje, ker ima Haskell koinduktivne tipe.</p>
<p>V Haskellu podatkovne tipe pišemo nekoliko drugače:</p>
<ul class="simple">
<li><p>imena tipov se piše z velikimi začetnicami: <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, <code class="docutils literal notranslate"><span class="pre">Integer</span></code>, …</p></li>
<li><p>produkt tipov <code class="docutils literal notranslate"><span class="pre">a</span></code> in <code class="docutils literal notranslate"><span class="pre">b</span></code> zapišemo <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code>, se pravi tako kot urejene pare. Na
primer, elementi tipa <code class="docutils literal notranslate"><span class="pre">(Bool,</span> <span class="pre">Int)</span></code> so <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">42)</span></code>, <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">23)</span></code> itd.</p></li>
<li><p>enotski tip pišemo <code class="docutils literal notranslate"><span class="pre">()</span></code>, torej tako kot njegovo edino vrednost.</p></li>
<li><p>zapis <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">::</span> <span class="pre">t</span></code> pomeni »<code class="docutils literal notranslate"><span class="pre">e</span></code> ima tip <code class="docutils literal notranslate"><span class="pre">t</span></code>«, zapis <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span></code> pa seznam z glavo <code class="docutils literal notranslate"><span class="pre">e</span></code>
in repom <code class="docutils literal notranslate"><span class="pre">t</span></code> (ravno obratno, kot v OCamlu)</p></li>
<li><p>podatkovni tip uvedemo z določilom <code class="docutils literal notranslate"><span class="pre">data</span></code> in parameter pišemo za ime tipa z
malimi črkami. Torej namesto <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">stream</span></code> zapišemo <code class="docutils literal notranslate"><span class="pre">Stream</span> <span class="pre">a</span></code>.</p></li>
</ul>
<p>A to so le podrobnosti konkretne sintakse.</p>
<p>Poglejmo definicijo tokov in njihovo uporavo na preprostih primerih:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- neskončen podatkovni tok elementov tipa a</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- Prvih n elementov toka pretvori v seznam</span><span class="w"></span>
<span class="nf">to_list</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">to_list</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">to_list</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">to_list</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- rep podatkovnega toka</span><span class="w"></span>
<span class="nf">rest</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">rest</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="c1">-- konstantni podatkovni tok, ki vedno vrača x</span><span class="w"></span>
<span class="nf">constant</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">constant</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">constant</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- uporabi funkcijo na vseh elementih toka</span><span class="w"></span>
<span class="nf">streamMap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">streamMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">streamMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- spni dva tokova z dano funkcijo</span><span class="w"></span>
<span class="nf">streamZip</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">streamZip</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">streamZip</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- filtriraj tok z dano Boolovo funkcijo</span><span class="w"></span>
<span class="nf">streamFilter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">streamFilter</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">streamFilter</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">streamFilter</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="c1">-- Tok naravnih števil</span><span class="w"></span>
<span class="nf">natural</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">streamMap</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">natural</span><span class="w"></span>

<span class="c1">-- Tok števil od n naprej</span><span class="w"></span>
<span class="nf">naturalFrom</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="nf">naturalFrom</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">naturalFrom</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- Kvadrati naravnih števil</span><span class="w"></span>
<span class="nf">squares</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">streamMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">natural</span><span class="w"></span>

<span class="c1">-- Fibonaccijeva števila</span><span class="w"></span>
<span class="nf">fibonacci</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">streamZip</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="n">fibonacci</span><span class="w"> </span><span class="p">(</span><span class="n">rest</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- Eratostenovo sito in praštevila</span><span class="w"></span>
<span class="nf">erastoten</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="nf">erastoten</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kt">Cons</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">erastoten</span><span class="w"> </span><span class="p">(</span><span class="n">streamFilter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>

<span class="nf">primes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="nf">primes</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">erastoten</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">naturalFrom</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="tokovi-v-ocamlu">
<h3><span class="section-number">6.4.3. </span>Tokovi v OCamlu<a class="headerlink" href="06-rekurzija.html#tokovi-v-ocamlu" title="Povezava na naslov">¶</a></h3>
<p>V OCaml lahko <em>simuliramo</em> tokove z uporabo tehnike <em>zavlačevanja</em> (angl. »thunk«).</p>
<p>Denimo da imamo izraz <code class="docutils literal notranslate"><span class="pre">e</span></code> tipa <code class="docutils literal notranslate"><span class="pre">t</span></code>, ki ga zaenkrat še ne želimo izračunati. Tedaj ga lahko
predelamo v funkcijo <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> (po angleško se imenuje taka funkcija <em>thunk</em>), ki je
tipa <code class="docutils literal notranslate"><span class="pre">unit</span> <span class="pre">-&gt;</span> <span class="pre">t</span></code>. Ker je <code class="docutils literal notranslate"><span class="pre">e</span></code> znotraj telesa funkcije, se bo izračunal šele, ko funkcijo
uporabimo na <code class="docutils literal notranslate"><span class="pre">()</span></code>. Od tod dobimo idejo, kako bi predstavili t.i. lene vrednosti v OCaml:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">stream</span><span class="o">)</span>
</pre></div>
</div>
<p>Primeri uporabe:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="o">(</span><span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">stream</span><span class="o">)</span>

<span class="c">(* Neskončni tok enic *)</span>
<span class="k">let</span> <span class="n">enice</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">e</span> <span class="bp">()</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">e</span> <span class="bp">()</span>

<span class="c">(* Neskončni tok k, k+1, k+2, ... *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">count</span> <span class="n">k</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">count</span> <span class="o">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">)))</span>

<span class="c">(* Neskončni tok enic *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">enice</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">generate</span> <span class="bp">()</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">generate</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">generate</span> <span class="bp">()</span>

<span class="c">(* Prvih n elementov toka pretvori v seznam *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">to_list</span> <span class="n">k</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">to_list</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">()</span><span class="o">)</span>

<span class="c">(* n-ti element toka *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">elementAt</span> <span class="n">k</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="o">_))</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="nc">Cons</span> <span class="o">(_,</span> <span class="n">s</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">elementAt</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">()</span><span class="o">)</span>

<span class="c">(* Potenčne vrste. Tok a₀, a₁, a₂, ... predstavlja potenčno vrsto</span>

<span class="c">      a₀ + a₁ x + a₂ x² + a₃ x³ + ...</span>
<span class="c"> *)</span>

<span class="c">(* Izračunaj vrednost potenčne vrste s v točki x, uporabi prvih n členov *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">eval</span> <span class="n">n</span> <span class="n">x</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">k</span> <span class="n">xpow</span> <span class="n">v</span> <span class="o">(</span><span class="nc">Cons</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">k</span> <span class="k">with</span>
    <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">v</span>
    <span class="o">|</span> <span class="n">k</span> <span class="o">-&gt;</span>  <span class="n">loop</span> <span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">xpow</span> <span class="o">*.</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">+.</span> <span class="n">a</span> <span class="o">*.</span> <span class="n">xpow</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="bp">()</span><span class="o">)</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="n">n</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="n">s</span>

<span class="c">(* V pythonu:</span>

<span class="c">   def eval (n, x, s):</span>
<span class="c">     k = n</span>
<span class="c">     xpow = 1.0</span>
<span class="c">     v = 0</span>
<span class="c">     while k &gt; 0:</span>
<span class="c">       a = s.getNext()</span>
<span class="c">       v = v + a * xpow</span>
<span class="c">       xpow = xpow * x</span>
<span class="c">       k = k - 1</span>
<span class="c">     return v</span>
<span class="c"> *)</span>

<span class="c">(* Potenčna vrsta za eksponentno funkcijo exp(x). Koeficienti so:</span>

<span class="c">   1/0!, 1/1!, 1/2!, 1/3!, 1/4!, …</span>
<span class="c"> *)</span>
<span class="k">let</span> <span class="n">exp</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">exp</span> <span class="n">k</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">exp</span> <span class="o">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">/.</span> <span class="kt">float</span> <span class="n">k</span><span class="o">))</span> <span class="k">in</span>
  <span class="n">exp</span> <span class="mi">1</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span>

<span class="c">(* Potenčna vrsta za sinus *)</span>
<span class="k">let</span> <span class="n">sin</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">sin</span> <span class="n">k</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">,</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">sin</span> <span class="o">(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">(-.</span> <span class="n">a</span> <span class="o">/.</span> <span class="kt">float</span> <span class="o">(</span><span class="n">k</span> <span class="o">*</span> <span class="o">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">)))))</span>
  <span class="k">in</span> <span class="n">sin</span> <span class="mi">2</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span>

<span class="c">(* Odvod vrste</span>

<span class="c">      a₀ + a₁ x + a₂ x² + a₃ x³ + a₄ x⁴ + ...</span>

<span class="c">   je</span>

<span class="c">      a₁ + 2 a₂ x¹ + 3 a₃ x² + 4 a₄ x³ + ...</span>

<span class="c"> *)</span>
<span class="k">let</span> <span class="n">diff</span> <span class="o">(</span><span class="nc">Cons</span> <span class="o">(_,</span> <span class="n">s</span><span class="o">))</span> <span class="o">=</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">diff&#39;</span> <span class="n">k</span> <span class="o">(</span><span class="nc">Cons</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="o">(</span><span class="kt">float</span> <span class="n">k</span> <span class="o">*.</span> <span class="n">a</span><span class="o">,</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">diff&#39;</span> <span class="o">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">()</span><span class="o">))</span>
      <span class="k">in</span> <span class="n">diff&#39;</span> <span class="mi">1</span> <span class="o">(</span><span class="n">s</span> <span class="bp">()</span><span class="o">)</span>

<span class="k">let</span> <span class="n">cos</span> <span class="o">=</span> <span class="n">diff</span> <span class="n">sin</span>
</pre></div>
</div>
</div>
<div class="section" id="vhod-izhod-kot-koinduktivni-tip">
<h3><span class="section-number">6.4.4. </span>Vhod/izhod kot koinduktivni tip<a class="headerlink" href="06-rekurzija.html#vhod-izhod-kot-koinduktivni-tip" title="Povezava na naslov">¶</a></h3>
<p>Še en primer koinduktivnega tipa je vhod/izhod (input/output). Tokrat s koinduktivnim tipom izrazimo strukturo programa, ki izvaja operaciji <code class="docutils literal notranslate"><span class="pre">Read</span></code> in <code class="docutils literal notranslate"><span class="pre">Write</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Program, ki simulira operaciji Read in Write s podatkovnim tipom</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">InputOutput</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kt">Read</span><span class="w"> </span><span class="p">(</span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">InputOutput</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="c1">-- program prebere niz in nadaljuje delo</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Write</span><span class="w"> </span><span class="p">(</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="kt">InputOutput</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">  </span><span class="c1">-- program izpiše niz in nadaljuje delo</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Return</span><span class="w"> </span><span class="n">a</span><span class="w">                       </span><span class="c1">-- program konča z danim rezultatom</span><span class="w"></span>

<span class="c1">-- Primer: program, ki izpiše &quot;Hello, world!&quot; in konča z rezultatom ()</span><span class="w"></span>
<span class="nf">hello_world</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">InputOutput</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">hello_world</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Write</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">Return</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- Primer: greeter n uporabnika n-krat vpraša po imenu in ga pozdravi, nato</span><span class="w"></span>
<span class="c1">--         vrne 42</span><span class="w"></span>
<span class="nf">greeter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">InputOutput</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="nf">greeter</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Return</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="nf">greeter</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Write</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Your name?&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">Read</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Write</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Hello, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">greeter</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))))</span><span class="w"></span>

<span class="c1">-- Lahko bi naredili tudi potencialno neskončni program?</span><span class="w"></span>
<span class="nf">annoyance</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">InputOutput</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">annoyance</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Write</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Should I stop? (Y/N)&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">Read</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">answer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;Y&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Write</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Bye&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">Return</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="kr">_</span><span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">annoyance</span><span class="w"> </span><span class="p">}))</span><span class="w"></span>

<span class="c1">-- Ker simuliramo I/O, moramo simulirati tudi operacijski sistem.</span><span class="w"></span>
<span class="c1">-- To naredimo s funkcijo, ki sprejme seznam vhodnih nizov,</span><span class="w"></span>
<span class="c1">-- niz, v katerem hranimo do sedaj izpisane podatke, in program.</span><span class="w"></span>
<span class="c1">-- Funkcija vrne rezultat programa in skupni niz, ki ga je program izpisal.</span><span class="w"></span>
<span class="nf">os</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">InputOutput</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">String</span><span class="p">)</span><span class="w"></span>
<span class="nf">os</span><span class="w">  </span><span class="kr">_</span><span class="w">            </span><span class="n">output</span><span class="w"> </span><span class="p">(</span><span class="kt">Return</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="nf">os</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="p">(</span><span class="kt">Read</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w">         </span><span class="ow">=</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"></span>
<span class="nf">os</span><span class="w"> </span><span class="kt">[]</span><span class="w">            </span><span class="n">output</span><span class="w"> </span><span class="p">(</span><span class="kt">Read</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w">         </span><span class="ow">=</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;kernel panic: input not available&quot;</span><span class="w"></span>
<span class="nf">os</span><span class="w"> </span><span class="n">input</span><span class="w">         </span><span class="n">output</span><span class="w"> </span><span class="p">(</span><span class="kt">Write</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">(</span><span class="n">output</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"></span>

<span class="nf">primer1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="n">hello_world</span><span class="w"></span>
<span class="c1">-- Dobimo: ((),&quot;Hello, world!&quot;)</span><span class="w"></span>

<span class="nf">primer2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;Janezek&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Micka&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Mojca&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Darko&quot;</span><span class="p">]</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">greeter</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"></span>
<span class="c1">-- Dobimo: (42,&quot;Your name?Hello, JanezekYour name?Hello, MickaYour name?Hello, Mojca&quot;)</span><span class="w"></span>

<span class="nf">primer3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;Janezek&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Micka&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Mojca&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Darko&quot;</span><span class="p">]</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">greeter</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="c1">-- Dobimo izjemo: *** Exception: kernel panic: input not available</span><span class="w"></span>

<span class="c1">-- Neskončen seznam &quot;N&quot;</span><span class="w"></span>
<span class="nf">no</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;N&quot;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">no</span><span class="w"></span>
<span class="nf">primer4</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="n">annoyance</span><span class="w"></span>
<span class="c1">-- Dobimo: se zacikla</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./06-rekurzija"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="../05-deklarativno-programiranje/05-deklarativno-programiranje.html" title="nazaj page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">nazaj</p>
            <p class="prev-next-title"><span class="section-number">5. </span>Deklarativno programiranje</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../07-izpeljava-tipov/07-izpeljava-tipov.html" title="naprej page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">naprej</p>
        <p class="prev-next-title"><span class="section-number">7. </span>Izpeljava tipov</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      Avtor Andrej Bauer<br/>
    
        &copy; avtorske pravice 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>